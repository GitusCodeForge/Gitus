* webhooks

It's better to use webhooks because it's very easy to turn git hooks into a security nightmare.

Webhooks are a kind of notification mechanism. When enabled, a POST request with necessary data like commit ids and such would be sent to the pre-configured URL; the receiving end of the POST request could then move on to perform different actions.

Webhooks for repositories in Gitus are introduced with the following steps:

+ Enable webhook in repository setting.
+ Add repository-specific secret key. This key should be shared w/ the receiving end.
+ Configure URL in repository setting.

After enabling, the corresponding =update= git hook would be set with a shell script that invokes the command =gitus webhook send=.

** Verification

POST requests sent by Gitus come with an =Authentication= header of the following format:

#+begin_example
Authorization: Bearer webhook-jwt-{token}
#+end_example

...where =token= is a JWT token of the following format:

+ Header: the following:

  #+begin_src json
  {
      "alg": "HS256",
      "typ": "JWT"
  }
  #+end_src json

  ...Gitus uses HMAC SHA-256.
+ Payload: the following:

  #+begin_src json
  {
      "iss": "{timestamp}",
      "nonce": "{nonce; in integer}",
  }
  #+end_src json
+ Signature: signature signed with the pre-configured secret.

The receiving end must verify the signature with the shared pre-configured secret.

** Data structure

Data structure are similar to GitHub webhooks:

#+begin_src json
  {
  	"id": "{uuid of this webhook request}"
  	"result_report": "{result report url; see below}"
  	"result_report_id": "{result report uuid; see below}"
  	"ref": "{updated reference}",
  	"before": "{before commit id}",
  	"after": "{after commit id}",
  	"commits": [
  		{
  			"id": "{commit id}",
  			"message": "{commit message}",
  			"url": "{commit url}",
  			"author": {
  				"name": "{git commit author name}",
  				"email": "{git commit author email}",
  				"username": "{gitus user name (if exists)}",
  			},
  			"committer": {
  				"name": "{git commit author name}",
  				"email": "{git commit author email}",
  				"username": "{gitus user name (if exists)}",
  			},
  			"timestamp": "{commit time; integer}"
  		}
  	],
  	"repository": {
  		"id": "{repository absolute id; integer}",
  		"owner": {
  			"id": "{repository owner user id; integer}",
  			"login": "{repository owner user name}",
  			"full_name": "{repo owner user full name}",
  			"email": "{repo owner user email}",
  			"username": "{repo owner user name}"
  		},
  		"name": "{repository name}",
  		"namespace": "{repository namespace}",
  		"full_name": "{repository full name, slash-separated}"
  		"description": "{repository description}",
  		"fork": "{is the repo a fork; boolean}",
  		"html_url": "{repo html url}",
  		"ssh_url": "{repo ssh url}",
  		"clone_url": "{repo http clone url}",
  	}
  }
#+end_src

** Command

The following command is executed:

#+begin_example
gitus web-hooks send "$repo_full_name" "$refname" "$newrev_type" "$oldrev" "$newrev"
#+end_example

...where:

+ =$repo_full_name=: full name of the corresponding repository, colon separated.
+ =$refname=: full name of the updated ref (e.g. =refs/heads/[branch]= instead of just =[branch]=).
+ =$newrev_type= would be the type of the update:
  + =commit=: new commit.
  + =delete=: delete tag.
  + =tag=: tag.
+ =$oldrev=: the id of commit before update
+ =$newrev=: the id of commit after update

** Result report

This provides a way for the external side to report the result of the webhook. The result report endpoint currently (2025.9.20) supports JSON only. The request header should also contain the same format of JWT.

#+begin_example
Authorization: Bearer webhook-jwt-{token}
Content-Type: application/json
#+end_example

The payload part of the JWT, however, is different. The webhook request would send, alongside with other info, a special "result report id"; this should be included in the ~jti~ claim of the payload and used to generate the signature. Gitus will not accept the same result report id more than once.

#+begin_src json
  {
  	"iss": "{timestamp}",
  	"jti": "{result report id}"
  }
#+end_src

The request body should be like the following:

#+begin_src json
  {
  	"ver": 0,
  	"id": "{webhook request uuid}",
  	"status": "{status code in integer; 1 - success, 2 - failed}",
  	"message": "{accompanying message; string}"
  }
#+end_src


